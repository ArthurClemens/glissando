{"version":3,"file":"glissando-helpers.js","sources":["../src/index.ts"],"sourcesContent":["const pathToTrail = (path: string) => {\n  const prefix = path.indexOf('/') === -1 ? '' : '/';\n  if (prefix === '') {\n    return [path];\n  }\n  return path\n    .split(prefix)\n    .filter(Boolean)\n    .map(fragment => `${prefix}${fragment}`)\n    .reduce((acc, fragment) => {\n      const previousPath = acc[acc.length - 1];\n      const combined = `${previousPath || ''}${fragment}`;\n      return [...acc, combined];\n    }, [] as string[]);\n};\n\nconst consolidateTrails = (\n  path: string = '',\n  pathTrail: string[],\n  modelTrail: string[] = [],\n) => {\n  const pathDepth = path.split('/').length;\n\n  const longest = pathTrail.length > modelTrail.length ? pathTrail : modelTrail;\n\n  type ProcessData = {\n    pathTrailIndex: number;\n    foundMatch: boolean;\n    foundMatchDepth: number;\n    invalidate: boolean;\n    paths: string[];\n  };\n  const result = longest.reduce(\n    (acc, p, i) => {\n      const { pathTrailIndex, foundMatch, invalidate, foundMatchDepth } = acc;\n      if (invalidate) {\n        return acc;\n      }\n      const pathTrailPath = pathTrail[pathTrailIndex];\n      const modelPath = modelTrail[i] || '';\n\n      // Path trail matches model: foundMatch\n      if (pathTrailPath === modelPath) {\n        return {\n          ...acc,\n          foundMatch: true,\n          pathTrailIndex: pathTrailIndex + 1,\n          paths: [...acc.paths, pathTrailPath],\n        };\n      }\n\n      // Path trail does not match model: override and invalidate\n      // so that no other paths will be copied\n      if (foundMatch && pathTrailPath && pathTrailPath !== modelPath) {\n        return {\n          ...acc,\n          invalidate: true,\n          pathTrailIndex: pathTrailIndex + 1,\n          paths: [...acc.paths, pathTrailPath],\n        };\n      }\n\n      const modelPathDepth = modelPath.split('/').length;\n\n      // When a match was found, copy deeper levels from the model path\n      // as long as the start of these pathss match the input path.\n      if (\n        foundMatch &&\n        modelPathDepth >= foundMatchDepth &&\n        new RegExp(`^${path}[\\\\/$]`).test(modelPath)\n      ) {\n        return {\n          ...acc,\n          paths: [...acc.paths, modelPath],\n        };\n      }\n      // Copy model paths as long as they are not\n      // deeper than the input path.\n      if (!foundMatch && modelPathDepth <= foundMatchDepth) {\n        return {\n          ...acc,\n          paths: [...acc.paths, modelPath],\n        };\n      }\n      return acc;\n    },\n    {\n      pathTrailIndex: 0,\n      foundMatch: false,\n      foundMatchDepth: pathDepth,\n      invalidate: false,\n      paths: [],\n    } as ProcessData,\n  );\n\n  return result.paths.filter(Boolean);\n};\n\n/**\n * Helper function to create the list of locations (and the current location) from a path.\n * Creates a breadcrumb trail from the path and returns a new list of locations\n * based on the merge of the breadcrumb trail and the current model locations.\n * From path:\n *   \"/users/Ferdinand/details\"\n * The generated locations will be:\n *   [\"/users\", \"/users/Ferdinand\", \"/users/Ferdinand/details\"]\n *\n * Usage:\n *\n * const location = m.route.get();\n * const locations = createLocationsFromPath(\n *   location,\n *   model.getState().locations,\n * );\n */\n\nexport const createLocationsFromPath = (\n  path: string = '',\n  modelTrail: string[] = [],\n) => {\n  const pathTrail = pathToTrail(path);\n\n  if (modelTrail.length === 0) {\n    return pathTrail;\n  }\n\n  return consolidateTrails(path, pathTrail, modelTrail);\n};\n"],"names":["path","modelTrail","pathTrail","prefix","indexOf","split","filter","Boolean","map","fragment","reduce","acc","combined","length","pathToTrail","pathDepth","p","i","pathTrailIndex","foundMatch","invalidate","foundMatchDepth","pathTrailPath","modelPath","paths","modelPathDepth","RegExp","test","consolidateTrails"],"mappings":"kRAoHuC,CACrCA,EAAe,GACfC,EAAuB,MAEvB,MAAMC,EAxHY,CAACF,IACnB,MAAMG,GAAgC,IAAvBH,EAAKI,QAAQ,KAAc,GAAK,IAC/C,MAAe,KAAXD,EACK,CAACH,GAEHA,EACJK,MAAMF,GACNG,OAAOC,SACPC,KAAIC,GAAY,GAAGN,IAASM,MAC5BC,QAAO,CAACC,EAAKF,KACZ,MACMG,EAAW,GADID,EAAIA,EAAIE,OAAS,IACF,KAAKJ,IACzC,MAAO,IAAIE,EAAKC,KACf,KA2GaE,CAAYd,GAE9B,OAA0B,IAAtBC,EAAWY,OACNX,EA3Ge,EACxBF,EAAe,GACfE,EACAD,EAAuB,MAEvB,MAAMc,EAAYf,EAAKK,MAAM,KAAKQ,OA0ElC,OAxEgBX,EAAUW,OAASZ,EAAWY,OAASX,EAAYD,GAS5CS,QACrB,CAACC,EAAKK,EAAGC,KACP,MAAMC,eAAEA,EAAcC,WAAEA,EAAUC,WAAEA,EAAUC,gBAAEA,GAAoBV,EACpE,GAAIS,EACF,OAAOT,EAET,MAAMW,EAAgBpB,EAAUgB,GAC1BK,EAAYtB,EAAWgB,IAAM,GAGnC,GAAIK,IAAkBC,EACpB,sCACKZ,IACHQ,YAAY,EACZD,eAAgBA,EAAiB,EACjCM,MAAO,IAAIb,EAAIa,MAAOF,KAM1B,GAAIH,GAAcG,GAAiBA,IAAkBC,EACnD,sCACKZ,IACHS,YAAY,EACZF,eAAgBA,EAAiB,EACjCM,MAAO,IAAIb,EAAIa,MAAOF,KAI1B,MAAMG,EAAiBF,EAAUlB,MAAM,KAAKQ,OAI5C,OACEM,GACAM,GAAkBJ,GAClB,IAAIK,OAAO,IAAI1B,WAAc2B,KAAKJ,KAS/BJ,GAAcM,GAAkBJ,iCAN9BV,IACHa,MAAO,IAAIb,EAAIa,MAAOD,KAWnBZ,IAET,CACEO,eAAgB,EAChBC,YAAY,EACZE,gBAAiBN,EACjBK,YAAY,EACZI,MAAO,KAIGA,MAAMlB,OAAOC,UA+BpBqB,CAAkB5B,EAAME,EAAWD"}