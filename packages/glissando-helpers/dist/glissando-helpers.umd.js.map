{"version":3,"file":"glissando-helpers.umd.js","sources":["../src/index.ts"],"sourcesContent":["const pathToTrail = (path: string) => {\n  const prefix = path.indexOf('/') === -1 ? '' : '/';\n  if (prefix === '') {\n    return [path];\n  }\n  return path\n    .split(prefix)\n    .filter(Boolean)\n    .map(fragment => `${prefix}${fragment}`)\n    .reduce((acc, fragment) => {\n      const previousPath = acc[acc.length - 1];\n      const combined = `${previousPath || ''}${fragment}`;\n      return [...acc, combined];\n    }, [] as string[]);\n};\n\nconst consolidateTrails = (\n  path: string = '',\n  pathTrail: string[],\n  modelTrail: string[] = [],\n) => {\n  const pathDepth = path.split('/').length;\n\n  const longest = pathTrail.length > modelTrail.length ? pathTrail : modelTrail;\n\n  type ProcessData = {\n    pathTrailIndex: number;\n    foundMatch: boolean;\n    foundMatchDepth: number;\n    invalidate: boolean;\n    paths: string[];\n  };\n  const result = longest.reduce(\n    (acc, _p, i) => {\n      const { pathTrailIndex, foundMatch, invalidate, foundMatchDepth } = acc;\n      if (invalidate) {\n        return acc;\n      }\n      const pathTrailPath = pathTrail[pathTrailIndex];\n      const modelPath = modelTrail[i] || '';\n\n      // Path trail matches model: foundMatch\n      if (pathTrailPath === modelPath) {\n        return {\n          ...acc,\n          foundMatch: true,\n          pathTrailIndex: pathTrailIndex + 1,\n          paths: [...acc.paths, pathTrailPath],\n        };\n      }\n\n      // Path trail does not match model: override and invalidate\n      // so that no other paths will be copied\n      if (foundMatch && pathTrailPath && pathTrailPath !== modelPath) {\n        return {\n          ...acc,\n          invalidate: true,\n          pathTrailIndex: pathTrailIndex + 1,\n          paths: [...acc.paths, pathTrailPath],\n        };\n      }\n\n      const modelPathDepth = modelPath.split('/').length;\n\n      // When a match was found, copy deeper levels from the model path\n      // as long as the start of these pathss match the input path.\n      if (\n        foundMatch &&\n        modelPathDepth >= foundMatchDepth &&\n        new RegExp(`^${path}[\\\\/$]`).test(modelPath)\n      ) {\n        return {\n          ...acc,\n          paths: [...acc.paths, modelPath],\n        };\n      }\n      // Copy model paths as long as they are not\n      // deeper than the input path.\n      if (!foundMatch && modelPathDepth <= foundMatchDepth) {\n        return {\n          ...acc,\n          paths: [...acc.paths, modelPath],\n        };\n      }\n      return acc;\n    },\n    {\n      pathTrailIndex: 0,\n      foundMatch: false,\n      foundMatchDepth: pathDepth,\n      invalidate: false,\n      paths: [],\n    } as ProcessData,\n  );\n\n  return result.paths.filter(Boolean);\n};\n\n/**\n * Helper function to create the list of locations (and the current location) from a path.\n * Creates a breadcrumb trail from the path and returns a new list of locations\n * based on the merge of the breadcrumb trail and the current model locations.\n * From path:\n *   \"/users/Ferdinand/details\"\n * The generated locations will be:\n *   [\"/users\", \"/users/Ferdinand\", \"/users/Ferdinand/details\"]\n *\n * Usage:\n *\n * const location = m.route.get();\n * const locations = createLocationsFromPath(\n *   location,\n *   model.getState().locations,\n * );\n */\n\nexport const createLocationsFromPath = (\n  path: string = '',\n  modelTrail: string[] = [],\n) => {\n  const pathTrail = pathToTrail(path);\n\n  if (modelTrail.length === 0) {\n    return pathTrail;\n  }\n\n  return consolidateTrails(path, pathTrail, modelTrail);\n};\n"],"names":[],"mappings":";;;;AAAA,QAAM,cAAc,CAAC,SAAiB;AACpC,UAAM,SAAS,KAAK,QAAQ,GAAG,MAAM,KAAK,KAAK;AAC/C,QAAI,WAAW,IAAI;AACjB,aAAO,CAAC,IAAI;AAAA,IACd;AACA,WAAO,KACJ,MAAM,MAAM,EACZ,OAAO,OAAO,EACd,IAAI,CAAY,aAAA,GAAG,SAAS,UAAU,EACtC,OAAO,CAAC,KAAK,aAAa;AACzB,YAAM,eAAe,IAAI,IAAI,SAAS,CAAC;AACjC,YAAA,WAAW,GAAG,gBAAgB,KAAK;AAClC,aAAA,CAAC,GAAG,KAAK,QAAQ;AAAA,IAC1B,GAAG,CAAc,CAAA;AAAA,EACrB;AAEA,QAAM,oBAAoB,CACxB,OAAe,IACf,WACA,aAAuB,CAAA,MACpB;AACH,UAAM,YAAY,KAAK,MAAM,GAAG,EAAE;AAElC,UAAM,UAAU,UAAU,SAAS,WAAW,SAAS,YAAY;AASnE,UAAM,SAAS,QAAQ;AAAA,MACrB,CAAC,KAAK,IAAI,MAAM;AACd,cAAM,EAAE,gBAAgB,YAAY,YAAY,oBAAoB;AACpE,YAAI,YAAY;AACP,iBAAA;AAAA,QACT;AACM,cAAA,gBAAgB,UAAU,cAAc;AACxC,cAAA,YAAY,WAAW,CAAC,KAAK;AAGnC,YAAI,kBAAkB,WAAW;AACxB,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,YAAY;AAAA,YACZ,gBAAgB,iBAAiB;AAAA,YACjC,OAAO,CAAC,GAAG,IAAI,OAAO,aAAa;AAAA,UAAA;AAAA,QAEvC;AAII,YAAA,cAAc,iBAAiB,kBAAkB,WAAW;AACvD,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,YAAY;AAAA,YACZ,gBAAgB,iBAAiB;AAAA,YACjC,OAAO,CAAC,GAAG,IAAI,OAAO,aAAa;AAAA,UAAA;AAAA,QAEvC;AAEA,cAAM,iBAAiB,UAAU,MAAM,GAAG,EAAE;AAK1C,YAAA,cACA,kBAAkB,mBAClB,IAAI,OAAO,IAAI,YAAY,EAAE,KAAK,SAAS,GAC3C;AACO,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,OAAO,CAAC,GAAG,IAAI,OAAO,SAAS;AAAA,UAAA;AAAA,QAEnC;AAGI,YAAA,CAAC,cAAc,kBAAkB,iBAAiB;AAC7C,iBAAA;AAAA,YACL,GAAG;AAAA,YACH,OAAO,CAAC,GAAG,IAAI,OAAO,SAAS;AAAA,UAAA;AAAA,QAEnC;AACO,eAAA;AAAA,MACT;AAAA,MACA;AAAA,QACE,gBAAgB;AAAA,QAChB,YAAY;AAAA,QACZ,iBAAiB;AAAA,QACjB,YAAY;AAAA,QACZ,OAAO,CAAC;AAAA,MACV;AAAA,IAAA;AAGK,WAAA,OAAO,MAAM,OAAO,OAAO;AAAA,EACpC;AAoBa,QAAA,0BAA0B,CACrC,OAAe,IACf,aAAuB,CAAA,MACpB;AACG,UAAA,YAAY,YAAY,IAAI;AAE9B,QAAA,WAAW,WAAW,GAAG;AACpB,aAAA;AAAA,IACT;AAEO,WAAA,kBAAkB,MAAM,WAAW,UAAU;AAAA,EACtD;;;;"}