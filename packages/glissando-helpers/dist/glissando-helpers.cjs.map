{"version":3,"file":"glissando-helpers.cjs","sources":["../src/index.ts"],"sourcesContent":["const pathToTrail = (path: string) => {\n  const prefix = path.indexOf('/') === -1 ? '' : '/';\n  if (prefix === '') {\n    return [path];\n  }\n  return path\n    .split(prefix)\n    .filter(Boolean)\n    .map(fragment => `${prefix}${fragment}`)\n    .reduce((acc, fragment) => {\n      const previousPath = acc[acc.length - 1];\n      const combined = `${previousPath || ''}${fragment}`;\n      return [...acc, combined];\n    }, [] as string[]);\n};\n\nconst consolidateTrails = (\n  path: string = '',\n  pathTrail: string[],\n  modelTrail: string[] = [],\n) => {\n  const pathDepth = path.split('/').length;\n\n  const longest = pathTrail.length > modelTrail.length ? pathTrail : modelTrail;\n\n  type ProcessData = {\n    pathTrailIndex: number;\n    foundMatch: boolean;\n    foundMatchDepth: number;\n    invalidate: boolean;\n    paths: string[];\n  };\n  const result = longest.reduce(\n    (acc, _p, i) => {\n      const { pathTrailIndex, foundMatch, invalidate, foundMatchDepth } = acc;\n      if (invalidate) {\n        return acc;\n      }\n      const pathTrailPath = pathTrail[pathTrailIndex];\n      const modelPath = modelTrail[i] || '';\n\n      // Path trail matches model: foundMatch\n      if (pathTrailPath === modelPath) {\n        return {\n          ...acc,\n          foundMatch: true,\n          pathTrailIndex: pathTrailIndex + 1,\n          paths: [...acc.paths, pathTrailPath],\n        };\n      }\n\n      // Path trail does not match model: override and invalidate\n      // so that no other paths will be copied\n      if (foundMatch && pathTrailPath && pathTrailPath !== modelPath) {\n        return {\n          ...acc,\n          invalidate: true,\n          pathTrailIndex: pathTrailIndex + 1,\n          paths: [...acc.paths, pathTrailPath],\n        };\n      }\n\n      const modelPathDepth = modelPath.split('/').length;\n\n      // When a match was found, copy deeper levels from the model path\n      // as long as the start of these pathss match the input path.\n      if (\n        foundMatch &&\n        modelPathDepth >= foundMatchDepth &&\n        new RegExp(`^${path}[\\\\/$]`).test(modelPath)\n      ) {\n        return {\n          ...acc,\n          paths: [...acc.paths, modelPath],\n        };\n      }\n      // Copy model paths as long as they are not\n      // deeper than the input path.\n      if (!foundMatch && modelPathDepth <= foundMatchDepth) {\n        return {\n          ...acc,\n          paths: [...acc.paths, modelPath],\n        };\n      }\n      return acc;\n    },\n    {\n      pathTrailIndex: 0,\n      foundMatch: false,\n      foundMatchDepth: pathDepth,\n      invalidate: false,\n      paths: [],\n    } as ProcessData,\n  );\n\n  return result.paths.filter(Boolean);\n};\n\n/**\n * Helper function to create the list of locations (and the current location) from a path.\n * Creates a breadcrumb trail from the path and returns a new list of locations\n * based on the merge of the breadcrumb trail and the current model locations.\n * From path:\n *   \"/users/Ferdinand/details\"\n * The generated locations will be:\n *   [\"/users\", \"/users/Ferdinand\", \"/users/Ferdinand/details\"]\n *\n * Usage:\n *\n * const location = m.route.get();\n * const locations = createLocationsFromPath(\n *   location,\n *   model.getState().locations,\n * );\n */\n\nexport const createLocationsFromPath = (\n  path: string = '',\n  modelTrail: string[] = [],\n) => {\n  const pathTrail = pathToTrail(path);\n\n  if (modelTrail.length === 0) {\n    return pathTrail;\n  }\n\n  return consolidateTrails(path, pathTrail, modelTrail);\n};\n"],"names":[],"mappings":";;AAAA,MAAM,cAAc,CAAC,SAAiB;AACpC,QAAM,SAAS,KAAK,QAAQ,GAAG,MAAM,KAAK,KAAK;AAC/C,MAAI,WAAW,IAAI;AACjB,WAAO,CAAC,IAAI;AAAA,EACd;AACA,SAAO,KACJ,MAAM,MAAM,EACZ,OAAO,OAAO,EACd,IAAI,CAAY,aAAA,GAAG,SAAS,UAAU,EACtC,OAAO,CAAC,KAAK,aAAa;AACzB,UAAM,eAAe,IAAI,IAAI,SAAS,CAAC;AACjC,UAAA,WAAW,GAAG,gBAAgB,KAAK;AAClC,WAAA,CAAC,GAAG,KAAK,QAAQ;AAAA,EAC1B,GAAG,CAAc,CAAA;AACrB;AAEA,MAAM,oBAAoB,CACxB,OAAe,IACf,WACA,aAAuB,CAAA,MACpB;AACH,QAAM,YAAY,KAAK,MAAM,GAAG,EAAE;AAElC,QAAM,UAAU,UAAU,SAAS,WAAW,SAAS,YAAY;AASnE,QAAM,SAAS,QAAQ;AAAA,IACrB,CAAC,KAAK,IAAI,MAAM;AACd,YAAM,EAAE,gBAAgB,YAAY,YAAY,oBAAoB;AACpE,UAAI,YAAY;AACP,eAAA;AAAA,MACT;AACM,YAAA,gBAAgB,UAAU,cAAc;AACxC,YAAA,YAAY,WAAW,CAAC,KAAK;AAGnC,UAAI,kBAAkB,WAAW;AACxB,eAAA;AAAA,UACL,GAAG;AAAA,UACH,YAAY;AAAA,UACZ,gBAAgB,iBAAiB;AAAA,UACjC,OAAO,CAAC,GAAG,IAAI,OAAO,aAAa;AAAA,QAAA;AAAA,MAEvC;AAII,UAAA,cAAc,iBAAiB,kBAAkB,WAAW;AACvD,eAAA;AAAA,UACL,GAAG;AAAA,UACH,YAAY;AAAA,UACZ,gBAAgB,iBAAiB;AAAA,UACjC,OAAO,CAAC,GAAG,IAAI,OAAO,aAAa;AAAA,QAAA;AAAA,MAEvC;AAEA,YAAM,iBAAiB,UAAU,MAAM,GAAG,EAAE;AAK1C,UAAA,cACA,kBAAkB,mBAClB,IAAI,OAAO,IAAI,YAAY,EAAE,KAAK,SAAS,GAC3C;AACO,eAAA;AAAA,UACL,GAAG;AAAA,UACH,OAAO,CAAC,GAAG,IAAI,OAAO,SAAS;AAAA,QAAA;AAAA,MAEnC;AAGI,UAAA,CAAC,cAAc,kBAAkB,iBAAiB;AAC7C,eAAA;AAAA,UACL,GAAG;AAAA,UACH,OAAO,CAAC,GAAG,IAAI,OAAO,SAAS;AAAA,QAAA;AAAA,MAEnC;AACO,aAAA;AAAA,IACT;AAAA,IACA;AAAA,MACE,gBAAgB;AAAA,MAChB,YAAY;AAAA,MACZ,iBAAiB;AAAA,MACjB,YAAY;AAAA,MACZ,OAAO,CAAC;AAAA,IACV;AAAA,EAAA;AAGK,SAAA,OAAO,MAAM,OAAO,OAAO;AACpC;AAoBO,MAAM,0BAA0B,CACrC,OAAe,IACf,aAAuB,CAAA,MACpB;AACG,QAAA,YAAY,YAAY,IAAI;AAE9B,MAAA,WAAW,WAAW,GAAG;AACpB,WAAA;AAAA,EACT;AAEO,SAAA,kBAAkB,MAAM,WAAW,UAAU;AACtD;;"}