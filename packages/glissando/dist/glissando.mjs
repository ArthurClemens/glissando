import n from"mithril/stream";export{default as Stream}from"mithril/stream";const t=n=>t=>{const{newIndex:i,shouldUpdate:e}=((n,t)=>{if(void 0===t||Number.isNaN(t))return{newIndex:n.index,shouldUpdate:!1};const i=Math.min(t,n.count-1);return{newIndex:i,shouldUpdate:i>=0&&i<n.count&&i!==n.index}})(n,t.index);return e?{...n,...t.animate?void 0:{index:i},targetIndex:i,isAnimating:!!t.animate}:n},i=n=>t=>{if(!n.locations||!n.location)return;const i=n.locations.indexOf(n.location);return-1!==i?n.locations[t(i)]:void 0},e=(e={})=>{const a=e.sideViews||1,o=[...Array(1+2*a)].map((n,t)=>t-a),r={index:e.index||0,targetIndex:e.index||0,isAnimating:!1,count:0,direction:"ltr",slots:o,sideViews:a},s=n=>({previous:({animate:i}={animate:!0})=>{n(n=>t(n)({index:n.index-1,animate:!1!==i}))},next:({animate:i}={animate:!0})=>{n(n=>t(n)({index:n.index+1,animate:!1!==i}))},goTo:({index:i,location:e,animate:a})=>{n(n=>{if(e){const i={location:e,animate:a};return(n=>i=>{if(!n.locations||0===n.locations.length)return n;let e=i.location.toString(),a=n.locations.indexOf(e);-1===a&&(a=0,e=n.locations[a]);const o=void 0!==n.location&&!1!==i.animate,r={...n,location:e},s={index:a,animate:o};return t(r)(s)})(n)(i)}if(void 0===i)return n;const o={index:i,animate:a};return t(n)(o)})},finalize:i=>{n(n=>t(n)({index:i,animate:!1}))},setCount:i=>{n(n=>t({...n,count:i})({index:n.index}))},setDirection:t=>{n(n=>({...n,direction:t}))},setLocations:t=>{n(n=>({...n,locations:t}))}}),d=n=>({hasNext:()=>{const t=n();return t.index<t.count-1},hasPrevious:()=>n().index>0,isAnimating:()=>n().isAnimating,getViewIndices:()=>{const t=n();return o.map(n=>{let i=n+t.index+0;return n<0&&t.targetIndex<t.index?i=n+t.targetIndex+1:n>0&&t.targetIndex>t.index&&(i=n+t.targetIndex-1),i})},getLocation:()=>{const t=n();return i(t)(n=>n)},getNextLocation:()=>{const t=n();return i(t)(n=>n+1)},getPreviousLocation:()=>{const t=n();return i(t)(n=>n-1)}}),c=n(),x=n.scan((n,t)=>t(n),{...r},c),l={...s(c)},m={...d(x)},u=n.scan((t,i)=>JSON.stringify(t,null,2)===JSON.stringify(i,null,2)?n.SKIP:i,n.SKIP,x);return{getState:x,getChanges:n.lift(n=>n,u),...l,...m}},a=n=>{const t=2*n.sideViews+1,i=100/t,e="rtl"===n.direction?1:-1;let a=e*i*(n.sideViews+0);return n.targetIndex>n.index?a=e*i*(n.sideViews+1):n.targetIndex<n.index&&(a=e*i*(n.sideViews-1)),{style:{width:`${100*t}%`,transform:`translateX(${a}%)`,...n.isAnimating?void 0:{transitionDuration:"0ms"}},className:n.isAnimating?"glissando-animating":""}};export{e as GlissandoModel,a as getSliderStyle};
