{"version":3,"file":"glissando.js","sources":["../src/GlissandoModel.ts","../src/util.ts"],"sourcesContent":["import Stream from 'mithril/stream';\n\nimport type { Glissando } from './types';\n\ntype PatchFn = (state: Glissando.State) => Glissando.State;\n\nconst calculateNewIndex = (\n  state: Glissando.State,\n  index: number | undefined,\n) => {\n  if (index === undefined || Number.isNaN(index)) {\n    return {\n      newIndex: state.index,\n      shouldUpdate: false,\n    };\n  }\n  const newIndex = Math.min(index, state.count - 1);\n  const isValid = newIndex >= 0 && newIndex < state.count;\n  const shouldUpdate = isValid && newIndex !== state.index;\n  return {\n    newIndex,\n    shouldUpdate,\n  };\n};\n\nconst setIndex = (state: Glissando.State) => (\n  change: Glissando.IndexChange,\n) => {\n  const { newIndex, shouldUpdate } = calculateNewIndex(state, change.index);\n  return shouldUpdate\n    ? {\n        ...state,\n        ...(change.animate ? undefined : { index: newIndex }),\n        targetIndex: newIndex,\n        isAnimating: !!change.animate,\n      }\n    : state;\n};\n\nconst setLocation = (state: Glissando.State) => (\n  change: Glissando.LocationChange,\n) => {\n  if (!state.locations || state.locations.length === 0) {\n    return state;\n  }\n  let locationStr = change.location.toString();\n  let index = state.locations.indexOf(locationStr);\n  if (index === -1) {\n    // Location does not exist; default to first index\n    index = 0;\n    locationStr = state.locations[index];\n  }\n  const shouldAnimate =\n    state.location === undefined\n      ? false // don't animate if we are setting the first location\n      : change.animate !== false;\n  const newState = {\n    ...state,\n    location: locationStr,\n  };\n  const indexChange: Glissando.IndexChange = {\n    index,\n    animate: shouldAnimate,\n  };\n  return setIndex(newState)(indexChange);\n};\n\ntype IndexLocationChange = (index: number) => number;\n\nconst lookupLocation = (state: Glissando.State) => (\n  changeFn: IndexLocationChange,\n) => {\n  if (!state.locations || !state.location) {\n    return undefined;\n  }\n  const index = state.locations.indexOf(state.location);\n  if (index === -1) {\n    return undefined;\n  }\n  return state.locations[changeFn(index)];\n};\n\nconst getInitialState = (\n  {\n    index = 0,\n    count = 0,\n    sideViews = 1,\n    location,\n    locations,\n  }: Glissando.InitialState = {} as Glissando.InitialState,\n) => {\n  const slots = [...Array(1 + sideViews * 2)].map((_, i) => i - sideViews);\n  const initialState: Glissando.State = {\n    targetIndex: index,\n    index,\n    count,\n    ...(Array.isArray(locations)\n      ? {\n          locations,\n          count: locations ? locations.length : 0,\n          location: locations[0],\n        }\n      : undefined),\n    ...(location\n      ? {\n          location,\n          index: Array.isArray(locations)\n            ? locations.indexOf(location) || index\n            : index,\n        }\n      : undefined),\n    isAnimating: false,\n    direction: 'ltr', // set by libs glissando-mithril etc\n    slots,\n    sideViews,\n  };\n  initialState.targetIndex = initialState.index;\n  return initialState;\n};\n\nexport const GlissandoModel = (\n  props: Glissando.InitialState = {} as Glissando.InitialState,\n) => {\n  const initialState = getInitialState(props);\n\n  const glissandoState = {\n    initialState,\n    actions: (update: Stream<PatchFn>) => ({\n      previous: ({ animate }: { animate?: boolean } = { animate: true }) => {\n        update((state: Glissando.State) =>\n          setIndex(state)({\n            index: state.index - 1,\n            animate: animate !== false,\n          }),\n        );\n      },\n      next: ({ animate }: { animate?: boolean } = { animate: true }) => {\n        update((state: Glissando.State) =>\n          setIndex(state)({\n            index: state.index + 1,\n            animate: animate !== false,\n          }),\n        );\n      },\n      goTo: ({\n        index,\n        location,\n        animate,\n      }: {\n        index?: number;\n        location?: Glissando.Location;\n        animate?: boolean;\n      }) => {\n        update((state: Glissando.State) => {\n          if (location) {\n            const change: Glissando.LocationChange = {\n              location,\n              animate,\n            };\n            return setLocation(state)(change);\n          }\n          if (index === undefined) {\n            return state;\n          }\n          const change: Glissando.IndexChange = {\n            index,\n            animate,\n          };\n          return setIndex(state)(change);\n        });\n      },\n      finalize: (index: number) => {\n        update((state: Glissando.State) =>\n          setIndex(state)({\n            index,\n            animate: false,\n          }),\n        );\n      },\n      setCount: (count: number) => {\n        update((state: Glissando.State) =>\n          setIndex({\n            ...state,\n            count,\n          })({ index: state.index }),\n        );\n      },\n      setDirection: (direction: Glissando.Direction) => {\n        update((state: Glissando.State) => ({\n          ...state,\n          direction,\n        }));\n      },\n      setLocations: (locations: Glissando.Location[]) => {\n        update((state: Glissando.State) => ({\n          ...state,\n          locations,\n          count: locations.length,\n        }));\n      },\n    }),\n\n    selectors: (states: Stream<Glissando.State>) => ({\n      hasNext: () => {\n        const state = states();\n        return state.index < state.count - 1;\n      },\n      hasPrevious: () => {\n        const state = states();\n        return state.index > 0;\n      },\n      isAnimating: () => {\n        const state = states();\n        return state.isAnimating;\n      },\n      getViewIndices: () => {\n        const state = states();\n        return state.slots.map(slotIndex => {\n          let index = slotIndex + state.index + 0;\n          if (slotIndex < 0 && state.targetIndex < state.index) {\n            index = slotIndex + state.targetIndex + 1;\n          } else if (slotIndex > 0 && state.targetIndex > state.index) {\n            index = slotIndex + state.targetIndex - 1;\n          }\n          return index;\n        });\n      },\n      getLocation: () => {\n        const state = states();\n        return lookupLocation(state)(index => index);\n      },\n      getNextLocation: () => {\n        const state = states();\n        return lookupLocation(state)(index => index + 1);\n      },\n      getPreviousLocation: () => {\n        const state = states();\n        return lookupLocation(state)(index => index - 1);\n      },\n    }),\n  };\n\n  const update: Stream<PatchFn> = Stream<PatchFn>();\n\n  const states: Glissando.States = Stream.scan(\n    (state: Glissando.State, patch: PatchFn) => patch(state),\n    {\n      ...glissandoState.initialState,\n    },\n    update,\n  );\n\n  // Debugging:\n  // states.map(state => console.log(JSON.stringify(state, null, 2)));\n\n  const actions = {\n    ...glissandoState.actions(update),\n  };\n\n  const selectors: Glissando.Selectors = {\n    ...glissandoState.selectors(states),\n  };\n\n  const changedStates: Glissando.ChangedStates = Stream.scan(\n    (state: Glissando.ChangedState, value) =>\n      JSON.stringify(state, null, 2) === JSON.stringify(value, null, 2)\n        ? Stream.SKIP\n        : value,\n    Stream.SKIP,\n    states,\n  );\n\n  const getChanges = Stream.lift(\n    value => value as Glissando.State,\n    changedStates,\n  );\n\n  return {\n    getState: states,\n    getChanges,\n    ...actions,\n    ...selectors,\n  } as Glissando.Model;\n};\n","import type { Glissando } from './types';\n\n/**\n * Returns the classname and style object for the current model state.\n * Usage:\n *\n * const { className, style } = getSliderStyle(getState());\n * ...\n * <div\n *   className={`glissando-slider ${className}`}\n *   style={style}\n * >\n */\nexport const getSliderStyle = (state: Glissando.State) => {\n  const slotCount = 2 * state.sideViews + 1;\n  const slotWidth = 100 / slotCount;\n  const direction = state.direction === 'rtl' ? 1 : -1;\n  let sliderTranslateX: number = direction * slotWidth * (state.sideViews + 0);\n  if (state.targetIndex > state.index) {\n    sliderTranslateX = direction * slotWidth * (state.sideViews + 1);\n  } else if (state.targetIndex < state.index) {\n    sliderTranslateX = direction * slotWidth * (state.sideViews - 1);\n  }\n\n  const style = {\n    width: `calc(${slotCount} * calc(100%))`,\n    transform: `translateX(${sliderTranslateX}%)`,\n    ...(!state.isAnimating\n      ? {\n          transitionDuration: '0ms',\n        }\n      : undefined),\n  };\n  const className = state.isAnimating ? 'glissando-animating' : '';\n  return { style, className };\n};\n"],"names":["setIndex","state","change","newIndex","shouldUpdate","index","undefined","Number","isNaN","Math","min","count","calculateNewIndex","animate","targetIndex","isAnimating","lookupLocation","changeFn","locations","location","indexOf","props","glissandoState","initialState","sideViews","slots","Array","map","_","i","isArray","length","direction","getInitialState","actions","update","previous","next","goTo","locationStr","toString","shouldAnimate","newState","indexChange","setLocation","finalize","setCount","setDirection","setLocations","selectors","states","hasNext","hasPrevious","getViewIndices","slotIndex","getLocation","getNextLocation","getPreviousLocation","Stream","scan","patch","changedStates","value","JSON","stringify","SKIP","getChanges","lift","Object","getState","slotCount","slotWidth","sliderTranslateX","style","width","transform","transitionDuration","className"],"mappings":"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"}